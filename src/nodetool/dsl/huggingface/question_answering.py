# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.huggingface.question_answering
from nodetool.workflows.base_node import BaseNode


class QuestionAnswering(
    GraphNode[
        nodetool.nodes.huggingface.question_answering.QuestionAnswering.OutputType
    ]
):
    """

    Extracts answers to questions from a given text context using extractive QA models.
    text, question-answering, NLP, reading-comprehension

    Use cases:
    - Build automated FAQ and customer support systems
    - Extract specific information from documents and articles
    - Create reading comprehension and study tools
    - Enable natural language queries over text databases
    - Analyze contracts and legal documents for key details
    """

    model: types.HFQuestionAnswering | OutputHandle[types.HFQuestionAnswering] = (
        connect_field(
            default=types.HFQuestionAnswering(
                type="hf.question_answering",
                repo_id="",
                path=None,
                variant=None,
                allow_patterns=None,
                ignore_patterns=None,
            ),
            description="The extractive QA model. DistilBERT is fast; BERT-large and RoBERTa offer higher accuracy.",
        )
    )
    context: str | OutputHandle[str] = connect_field(
        default="",
        description="The text passage containing the information to answer questions from.",
    )
    question: str | OutputHandle[str] = connect_field(
        default="", description="The question to answer based on the provided context."
    )

    @property
    def out(self) -> "QuestionAnsweringOutputs":
        return QuestionAnsweringOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.huggingface.question_answering.QuestionAnswering

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class QuestionAnsweringOutputs(OutputsProxy):
    @property
    def answer(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["answer"])

    @property
    def score(self) -> OutputHandle[float]:
        return typing.cast(OutputHandle[float], self["score"])

    @property
    def start(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["start"])

    @property
    def end(self) -> OutputHandle[int]:
        return typing.cast(OutputHandle[int], self["end"])


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.huggingface.question_answering
from nodetool.workflows.base_node import BaseNode


class TableQuestionAnswering(
    GraphNode[
        nodetool.nodes.huggingface.question_answering.TableQuestionAnswering.OutputType
    ]
):
    """

    Answers natural language questions about tabular data using table QA models.
    table, question-answering, NLP, data-analysis

    Use cases:
    - Query spreadsheets and databases using natural language
    - Extract insights from financial reports and data tables
    - Build conversational interfaces for data exploration
    - Automate data analysis with question-based queries
    - Enable non-technical users to query structured data
    """

    model: (
        types.HFTableQuestionAnswering | OutputHandle[types.HFTableQuestionAnswering]
    ) = connect_field(
        default=types.HFTableQuestionAnswering(
            type="hf.table_question_answering",
            repo_id="",
            path=None,
            variant=None,
            allow_patterns=None,
            ignore_patterns=None,
        ),
        description="The table QA model. TAPAS models handle complex queries; TAPEX offers fact verification.",
    )
    dataframe: types.DataframeRef | OutputHandle[types.DataframeRef] = connect_field(
        default=types.DataframeRef(
            type="dataframe",
            uri="",
            asset_id=None,
            data=None,
            metadata=None,
            columns=None,
        ),
        description="The table data to query. Columns should have clear, descriptive headers.",
    )
    question: str | OutputHandle[str] = connect_field(
        default="",
        description="Your question about the table data (e.g., 'What is the total revenue?' or 'Which product sold the most?').",
    )

    @property
    def out(self) -> "TableQuestionAnsweringOutputs":
        return TableQuestionAnsweringOutputs(self)

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.huggingface.question_answering.TableQuestionAnswering

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


class TableQuestionAnsweringOutputs(OutputsProxy):
    @property
    def answer(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["answer"])

    @property
    def coordinates(self) -> OutputHandle[list[tuple[int, int]]]:
        return typing.cast(OutputHandle[list[tuple[int, int]]], self["coordinates"])

    @property
    def cells(self) -> OutputHandle[list[str]]:
        return typing.cast(OutputHandle[list[str]], self["cells"])

    @property
    def aggregator(self) -> OutputHandle[str]:
        return typing.cast(OutputHandle[str], self["aggregator"])
