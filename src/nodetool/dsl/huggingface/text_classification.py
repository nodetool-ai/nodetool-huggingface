# This file is auto-generated by nodetool.dsl.codegen.
# Please do not edit this file manually.

# Instead, edit the node class in the source module and run the following commands to regenerate the DSL:
# nodetool package scan
# nodetool codegen

from pydantic import BaseModel, Field
import typing
from typing import Any
import nodetool.metadata.types
import nodetool.metadata.types as types
from nodetool.dsl.graph import GraphNode, SingleOutputGraphNode

import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.huggingface.text_classification
from nodetool.workflows.base_node import BaseNode


class TextClassifier(
    SingleOutputGraphNode[dict[str, float]], GraphNode[dict[str, float]]
):
    """

    Classifies text into predefined categories using fine-tuned transformer models.
    text, classification, sentiment, NLP, emotion

    Use cases:
    - Analyze sentiment in social media posts and reviews
    - Detect emotions in customer feedback and conversations
    - Classify support tickets by category or priority
    - Filter spam or inappropriate content
    - Categorize news articles by topic
    """

    model: types.HFTextClassification | OutputHandle[types.HFTextClassification] = (
        connect_field(
            default=types.HFTextClassification(
                type="hf.text_classification",
                repo_id="",
                path=None,
                variant=None,
                allow_patterns=None,
                ignore_patterns=None,
            ),
            description="The text classification model. Use sentiment models for opinion analysis; emotion models for feeling detection.",
        )
    )
    prompt: str | OutputHandle[str] = connect_field(
        default="", description="The text to classify."
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.huggingface.text_classification.TextClassifier

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()


import typing
from pydantic import Field
from nodetool.dsl.handles import OutputHandle, OutputsProxy, connect_field
import nodetool.nodes.huggingface.text_classification
from nodetool.workflows.base_node import BaseNode


class ZeroShotTextClassifier(
    SingleOutputGraphNode[dict[str, float]], GraphNode[dict[str, float]]
):
    """

    Classifies text into custom categories without requiring task-specific training data.
    text, classification, zero-shot, NLP, flexible

    Use cases:
    - Classify text into custom, user-defined categories on the fly
    - Detect topics in documents without predefined training
    - Perform sentiment analysis with custom sentiment labels
    - Build flexible intent classification for conversational AI
    - Prototype classification systems with dynamic categories
    """

    model: (
        types.HFZeroShotClassification | OutputHandle[types.HFZeroShotClassification]
    ) = connect_field(
        default=types.HFZeroShotClassification(
            type="hf.zero_shot_classification",
            repo_id="",
            path=None,
            variant=None,
            allow_patterns=None,
            ignore_patterns=None,
        ),
        description="The zero-shot classification model. BART-large-mnli is reliable; DeBERTa variants offer improved accuracy; mDeBERTa is multilingual.",
    )
    inputs: str | OutputHandle[str] = connect_field(
        default="", description="The text to classify."
    )
    candidate_labels: str | OutputHandle[str] = connect_field(
        default="",
        description="Comma-separated list of labels to classify against (e.g., 'positive,negative,neutral' or 'sports,politics,technology').",
    )
    multi_label: bool | OutputHandle[bool] = connect_field(
        default=False,
        description="Allow multiple labels to be assigned to the same text (useful when text can belong to multiple categories).",
    )

    @classmethod
    def get_node_class(cls) -> type[BaseNode]:
        return nodetool.nodes.huggingface.text_classification.ZeroShotTextClassifier

    @classmethod
    def get_node_type(cls):
        return cls.get_node_class().get_node_type()
